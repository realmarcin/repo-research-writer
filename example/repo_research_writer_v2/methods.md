# Methods

## System Architecture

RRWrite was designed as an external repository analysis system that operates independently from the research repositories it documents. The system resides in a dedicated repository and analyzes target repositories via GitHub URLs or local filesystem paths, eliminating the need for researchers to modify their project structures. This external model enables RRWrite to process existing repositories without requiring PROJECT.md files or other custom configurations.

Output management follows a versioned directory structure where manuscripts are generated in `manuscript/<repo-name>_vN/` directories, with N representing the iteration number. The StateManager class implements version auto-increment by scanning existing directories and determining the next available version number. Each version contains all manuscript components including outline, sections, literature review, citations, and critique reports, enabling side-by-side comparison of iterative refinements. Workflow progress is tracked through a JSON-based state file (`.rrwrite/state.json`) that records completed phases, section statuses, file locations, and timestamps. This state tracking enables resumable execution, allowing researchers to interrupt and continue the manuscript generation process at any workflow stage.

Journal-specific configuration is managed through a YAML template system (`templates/manuscript_config.yaml`) that defines word count targets for different publication venues. The configuration supports Bioinformatics (6000 words total), Nature (3000 words total), and PLOS (unlimited) journals, with per-section limits for abstract, introduction, methods, results, and discussion. The configuration manager script (`rrwrite-config-manager.py`) enforces these constraints during section drafting, ensuring manuscripts adhere to journal guidelines with ±20% tolerance for natural variance.

## Four Core Skills

RRWrite implements manuscript generation through four integrated skills that operate sequentially within the Claude Code environment. Each skill is invoked as a command with a `--target-dir` parameter specifying the versioned output directory.

The **Planning** skill (`rrwrite-plan-manuscript`) generates structured outlines by first analyzing repository structure using the `rrwrite-analyze-repo.py` script, which scans directories up to 5 levels deep while excluding build artifacts and version control folders. The analyzer extracts data files, analysis scripts, figures, configuration files, and README content, then populates a template with repository statistics and inferred research topics. The planning skill synthesizes this information with journal-specific requirements to produce `outline.md`, which maps each manuscript section to evidence files in the repository and specifies word count targets. Validation ensures the outline conforms to the manuscript schema defined in `schemas/manuscript.yaml` using LinkML specifications [LinkML2024].

The **Research** skill (`rrwrite-research-literature`) conducts targeted literature reviews by extracting research topics from the outline and formulating 3-5 search queries combining core methods with domain terms. The skill uses web search to identify 15-25 papers across three categories: foundational work (pre-2020), recent advances (2024-2026), and direct competitors. For each paper, the skill captures authors, title, venue, year, DOI, and a direct quote of 1-2 sentences representing the key finding. This evidence is stored in `literature_evidence.csv` with columns for DOI, citation key, and verbatim quote, enabling verification chains from manuscript claims back to original sources. The skill generates three outputs: `literature.md` (structured 800-1000 word summary), `literature_citations.bib` (BibTeX entries with DOIs), and `literature_evidence.csv` (evidence tracker). All citations include DOIs for permanent identification.

The **Drafting** skill (`rrwrite-draft-section`) generates individual manuscript sections by loading word limits from the configuration manager, reading context files specified in the outline, and extracting relevant citation keys from BibTeX files. Section text is written in Markdown with LaTeX math notation and citation keys in `[key]` format (e.g., `[smith2020]`). The skill enforces formal academic prose style with passive voice for Methods sections and active voice for Results sections. Each section file follows the naming convention `{section_name}.md` (e.g., `methods.md`, `results.md`) as specified in the manuscript schema. After drafting, the skill validates section structure and updates workflow state by calling `StateManager.add_section_completed()`, which records the section name, completion timestamp, and current git commit hash.

The **Critique** skill (`rrwrite-critique-manuscript`) performs adversarial review of outlines, literature summaries, individual sections, or full manuscripts. The skill automatically detects document type and applies appropriate criteria: for outlines, it evaluates logical flow and evidence mapping; for literature reviews, it assesses coverage completeness and citation accuracy; for manuscripts, it checks technical accuracy, journal compliance, and citation integrity. Citation verification scans text for citation keys and cross-references them against BibTeX files, flagging missing keys as "HALLUCINATION RISK". Figure reference validation ensures sequential ordering and identifies unreferenced figures. The critique generates a structured report (`critique_{type}_vN.md`) with summary assessment, strengths, major issues (with impact and required actions), minor issues (with quick fixes), compliance checklist, and actionable next steps. Critique iteration numbers are managed by `StateManager.get_next_critique_version()`, which tracks all critique rounds in the workflow state.

## Verification Mechanisms

RRWrite implements multiple verification layers to maintain accuracy and traceability throughout manuscript generation. Statistical verification is performed via the `rrwrite-verify-stats.py` script, which accepts a data file path, column name, and operation (mean, max, min, std, count, median) as arguments. The script loads CSV or Excel files using pandas, applies optional query filters, and computes the requested statistic, enabling fact-checking of numerical claims against source data. While the protocol specifies that all numerical claims should be verified, in practice verification is applied selectively to key results due to computational constraints.

Citation evidence tracking maintains DOI and direct quote pairs in `literature_evidence.csv` for all references. This CSV file enables verification by providing the original source text that supports each citation, creating an auditable chain from manuscript claim to published evidence. The evidence file format uses three columns: `doi` (permanent identifier), `citation_key` (BibTeX key), and `evidence` (verbatim quote from the paper). Evidence quotes are extracted from paper abstracts or results sections during literature research and stored without paraphrasing to preserve original meaning.

Schema validation is performed by `rrwrite-validate-manuscript.py`, which checks file naming conventions, required fields, and structural constraints against the LinkML manuscript schema. The schema defines regex patterns for filenames (e.g., `^(abstract|introduction|methods|results|discussion)\\.md$` for sections), value ranges for word counts (minimum 50 words per section), and required attributes for each document type. Validation failures produce specific error messages identifying the violated constraint and expected format.

State validation ensures workflow completeness by tracking phase transitions and section completion in `state.json`. The state file records five workflow stages (plan, research, draft, critique, assembly) with status values (not_started, in_progress, completed), file paths, completion timestamps, and git commit hashes. For the draft stage, the state includes `sections_completed` and `sections_pending` arrays, enabling progress monitoring across multiple sections. The StateManager class provides methods to query state (`read_state()`), update stages (`update_workflow_stage()`), add critique iterations (`add_critique_iteration()`), and record verification runs (`record_verification()`), creating comprehensive workflow provenance.

## Workflow Orchestration

The main `/rrwrite` command orchestrates the complete manuscript generation pipeline by sequencing the four core skills with repository analysis and version management. The command accepts a GitHub URL or local path as the required first argument, with optional `--journal` (default: bioinformatics) and `--version` (default: auto) flags. Repository name normalization is performed by `rrwrite-normalize-repo-name.py`, which extracts clean directory names from URLs (e.g., `https://github.com/user/repo` → `repo`) or filesystem paths.

Version auto-increment scans the `manuscript/` directory for existing `<repo-name>_vN` directories using glob pattern matching and regex extraction. The `StateManager.get_next_version()` static method returns the maximum version number plus one, or 1 if no versions exist. For example, if `manuscript/my-repo_v1/` and `manuscript/my-repo_v3/` exist, the method returns 4. This approach allows non-consecutive version numbers and supports manual version specification via the `--version` parameter.

Resumable execution is enabled through state checking before each workflow phase. The main command reads `state.json` to determine completed stages and skips those that have already succeeded. Individual skill invocation is supported through phase-specific commands (e.g., `/rrwrite-draft-section methods --target-dir manuscript/repo_v1`), enabling targeted regeneration of specific sections without re-running the entire pipeline. The `rrwrite-status.py` script provides a progress dashboard showing completed phases, pending sections, file locations, and word counts, giving researchers visibility into workflow status.

Assembly of the final manuscript is performed by `rrwrite-assemble-manuscript.py`, which concatenates section files in order (abstract, introduction, methods, results, discussion, conclusion), adds section headers, appends literature citations from the BibTeX file, and generates `full_manuscript.md`. The assembled manuscript includes metadata headers with journal, version, generation date, and total word count. Section separation is maintained through Markdown horizontal rules, and citation formatting follows the journal-specific style extracted from the configuration template.
