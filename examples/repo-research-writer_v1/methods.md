# Algorithm

## Overall Architecture

RRWrite implements a modular skill-based architecture using the Claude Code framework [anthropic_skills]. The system consists of four core AI skills that operate as independent computational units, each responsible for a specific phase of manuscript generation. These skills communicate through a shared file system, exchanging data via structured Markdown files stored in the `manuscript/` directory. Each skill is defined using YAML frontmatter that specifies its name, description, allowed tools, and execution context.

The architecture enforces separation of concerns through context isolation. Skills execute in fork mode, preventing unintended side effects and enabling independent testing and version control. State coordination is achieved through a centralized StateManager (`scripts/rrwrite-state-manager.py`, 600+ lines) that tracks workflow progress in a JSON state file (`.rrwrite/state.json`). This hybrid approach combines the benefits of stateless functional programming with persistent workflow tracking.

Schema validation ensures output quality at every stage. A comprehensive LinkML schema (`schemas/manuscript.yaml`, 500+ lines) [matentzoglu2025linkml] defines the structure, naming conventions, and validation rules for all manuscript artifacts. The schema enforces patterns such as `^(abstract|introduction|methods|results|discussion|conclusion)\.md$` for section filenames and `^critique_(outline|literature|section|manuscript)_v[0-9]+\.md$` for critique reports, ensuring consistent file organization across projects.

The four core skills operate sequentially but can be invoked independently: `rrwrite-plan-manuscript` analyzes repository structure and generates journal-specific outlines; `rrwrite-draft-section` writes individual sections with automatic fact-checking; `rrwrite-research-literature` performs deep literature searches with citation management; and `rrwrite-critique-manuscript` provides adversarial review against journal standards. Each skill produces validated outputs that serve as inputs to subsequent stages, creating a pipeline from repository analysis to publication-ready text.

## Verification System

RRWrite enforces mandatory fact-checking through a two-tier verification system that prevents transcription errors and maintains scientific accuracy. The primary verification tool, `rrwrite-verify-stats.py` (86 lines), validates numerical claims against source data files. Given a CSV or Excel file, a column name, and a statistical operation (mean, max, min, std, count, median), the tool computes the statistic directly from the data and outputs the result. This enables the AI to verify that statements like "achieved 87% accuracy" match the actual values in `results/accuracy.csv`.

The verification workflow operates as follows: during section drafting, whenever the AI includes a numerical claim, it must invoke the verification tool to confirm the number exists in the source file. For example, to verify a mean accuracy claim, the system executes:

```bash
python scripts/rrwrite-verify-stats.py --file data/results.csv --col accuracy --op mean
```

The tool returns the computed mean, which the AI compares against its drafted text. If the values do not match, the text is revised before finalization. This process ensures complete provenance from raw data to published claims.

The second verification tier uses `rrwrite-validate-manuscript.py` (450 lines) to perform schema-based validation using LinkML [matentzoglu2025linkml]. After each skill produces output, the validation tool checks that filenames follow required patterns, required fields are present, and structural constraints are satisfied. For example, the validator confirms that literature reviews include all four required sections (Background, Related Work, Recent Advances, Research Gaps) and that critique reports include version numbers and recommendations.

Both verification tools are integrated into the skill protocols. The section drafting skill includes explicit fact-checking requirements: "Before finalizing a sentence containing a number, locate that number in the source file. If the number involves a calculation, generate a temporary Python script to compute it from the raw data and verify your claim." This mandatory verification step creates a verifiable audit trail from data files to manuscript text, addressing reproducibility concerns in computational research [kanwal2017provenance].

## Versioning and State Tracking

RRWrite implements a novel hybrid versioning system that combines Git version control with workflow-specific state tracking. Git manages collaborative editing and file history, while a dedicated state tracking system (`.rrwrite/state.json`) records workflow progress, critique iterations, and timestamped runs. This dual approach separates concerns: Git handles what changed in files, while the state file tracks where the workflow is and what remains to be done.

The StateManager class (`scripts/rrwrite-state-manager.py`) provides methods to initialize, read, and update workflow state. The state file contains five top-level sections: workflow status tracking (plan, research, draft, critique, assembly stages), archived runs with timestamps, provenance records linking claims to data files, Git integration metadata (commit hashes, branches), and critique iteration history with version numbers. State updates occur atomically after each skill completes successfully, ensuring the state file always reflects the most recent validated output.

Workflow progress is displayed using `rrwrite-status.py` (350 lines), which generates a visual dashboard showing completed stages, pending sections, critique iterations, and Git status. The display uses color-coded indicators and progress bars to convey workflow state at a glance. For example, after completing the Methods section, the status display shows "Draft stage: 1/5 sections complete (Methods)" and lists the remaining sections (Results, Introduction, Discussion, Abstract).

Run archiving enables manuscript versioning across major revisions. The `rrwrite-archive-run.py` tool (250 lines) creates timestamped snapshots of the entire manuscript directory, copying all generated files to `.rrwrite/runs/YYYY-MM-DD_HHMM/`. Each archived run includes the state file, all manuscript sections, critique reports, and provenance metadata. Runs can be compared using `rrwrite-compare-runs.py` (350 lines), which performs line-by-line diffs and highlights changes in word counts, citations, and verified claims. This archiving system supports iterative manuscript development, enabling authors to experiment with different journal formats or respond to reviewer feedback while maintaining access to previous versions.

Critique iterations use semantic versioning within a single run. Each critique generates a file named `critique_TYPE_vN.md` where N increments with each iteration (v1, v2, v3...). The state file tracks the recommendation from each iteration (ACCEPT_MINOR, MAJOR_REVISIONS, REJECT) and the number of major and minor issues identified. This enables tracking progress toward manuscript acceptance and provides a quantitative measure of revision quality.

## Workflow Stages

RRWrite implements a five-stage workflow that transforms research repositories into publication-ready manuscripts. Each stage is independent, can be executed multiple times, and produces validated outputs that feed into subsequent stages.

Stage 1 (Plan) analyzes the repository structure using `rrwrite-plan-manuscript`. The skill executes `tree -L 2 --prune` to map the project layout, locates data files (`*.csv`, `*.xlsx`), analysis scripts (`*.py`, `*.ipynb`), and figures (`*.png`, `*.pdf`), and reads `PROJECT.md` to understand research goals. Based on the target journal (Nature Methods, PLOS Computational Biology, or Bioinformatics), it adopts the appropriate structure and generates `manuscript/outline.md` with section-by-section descriptions, linked evidence files, and word count targets. The outline is validated against the schema and the workflow state is updated.

Stage 2 (Research) performs deep literature search using `rrwrite-research-literature`. The skill extracts research topics from `PROJECT.md` and `manuscript/outline.md`, formulates targeted search queries, and uses web search to find foundational papers (pre-2020), recent advances (2024-2026), and competing methods. For each relevant paper, it captures the DOI, extracts a direct quote representing the key finding, and creates a BibTeX entry. Three files are generated: `manuscript/literature.md` (structured 800-1000 word summary), `manuscript/literature_citations.bib` (BibTeX entries with DOIs), and `manuscript/literature_evidence.csv` (DOIs, citation keys, and direct quotes). This evidence file enables verification that manuscript claims accurately represent cited work.

Stage 3 (Draft) writes individual sections using `rrwrite-draft-section`. For each section, the skill reads `manuscript/outline.md` to identify evidence files, loads the specified data and code files, reads citation indices from `references.bib`, and generates text with proper formatting (LaTeX for math, citation keys in brackets). Before finalizing any numerical claim, the skill invokes `rrwrite-verify-stats.py` to confirm the number exists in the source data. Sections are written to `manuscript/SECTIONNAME.md` following the schema pattern and validated before the state is updated. This stage can be executed iteratively for different sections or to revise sections after critique.

Stage 4 (Critique) performs adversarial review using `rrwrite-critique-manuscript`. The skill adopts a "Reviewer 2" persona—critical, demanding, focused on reproducibility. It checks journal-specific compliance (abstract word counts, data availability statements), verifies citation integrity by scanning for citation keys and confirming they exist in `references.bib`, and checks figure references for logical ordering. The critique generates a structured report (`manuscript/critique_TYPE_vN.md`) with sections for summary assessment, strengths, major issues, minor issues, compliance checklist, and actionable next steps. Each critique includes a recommendation (Accept with minor revisions, Major revisions required, or Reject) and increments the version number. Multiple critique-revision cycles can occur until the manuscript reaches acceptable quality.

Stage 5 (Assembly) combines validated sections into a complete manuscript using `rrwrite-assemble-manuscript.py`. The tool concatenates sections in journal-specific order, validates the complete manuscript against the schema, generates a table of contents, and produces `manuscript/full_manuscript.md`. The final manuscript is ready for conversion to journal-required formats (LaTeX, DOCX, PDF) using external tools like Pandoc with journal-specific citation style files (CSL).

This five-stage workflow ensures that every manuscript artifact—from outline to final text—is validated, versioned, and traceable to source data, creating a reproducible pipeline from research repository to publication [rule2018jupyter, workflowhub].

## Technology Stack

RRWrite is implemented as a hybrid system combining shell scripting, Python libraries, and AI-powered skill execution through the Claude Code framework. The core verification tools are written in Python 3.7+ and leverage standard scientific computing libraries (pandas, openpyxl) for data manipulation and validation [achiam2023]. Installation automation is handled through a Bash script (`install.sh`) that manages both global and project-local configurations using symbolic links. State persistence relies on JSON serialization to track workflow progress across manuscript preparation stages. The schema definition uses LinkML, a formal modeling framework that enables strict validation of manuscript structure and naming conventions. All textual outputs are generated in Markdown format to facilitate version control integration and downstream conversion to LaTeX or Word formats.

Configuration management employs YAML files for both schema definition (`schemas/manuscript.yaml`) and skill metadata (YAML frontmatter in each `SKILL.md` file). This layered approach separates concerns between validation rules, execution context, and workflow logic. Git integration provides version history for manuscript artifacts and enables collaborative editing, while the JSON state file (`.rrwrite/state.json`) maintains orthogonal workflow progress tracking that is independent of Git history. This dual-versioning design allows researchers to commit manuscript changes without cluttering the state tracking with revision history, and conversely to track workflow completion status without triggering unnecessary Git commits.

## Skill System Details

Each of the four core skills (plan, research, draft, critique) is implemented as a self-contained module with YAML frontmatter configuration. The frontmatter specifies the skill name, description, allowed tool access, and execution context mode. For example, the `rrwrite-draft-section` skill declares `context: fork` to isolate its execution environment from the main conversation thread, preventing token context pollution during lengthy section generation tasks. This isolation is critical for managing the large context windows required when processing code files, data tables, and citation databases simultaneously.

Skills communicate exclusively through the file system using the `manuscript/` directory as a shared workspace. The planning skill writes `outline.md` containing section specifications and evidence file paths. The drafting skill reads this outline to determine which source files to load, then writes individual section files (`abstract.md`, `methods.md`, etc.) with embedded citation keys. The critique skill reads completed sections and generates versioned critique documents (`critique_manuscript_v1.md`) with structural and scientific feedback. This file-based message passing ensures reproducibility and allows manual inspection or editing at any workflow stage.

After each skill execution, state updates are performed programmatically via the StateManager class from `rrwrite-state-manager.py`. Skills call `add_section_completed(section_name)` or `increment_critique_iteration()` to update the workflow state file. The state manager enforces atomic updates using file locking to prevent race conditions if multiple skills execute concurrently. State transitions are timestamped and include Git commit hashes when available, creating an audit trail linking manuscript versions to repository snapshots. The `rrwrite-status.py` script provides a dashboard view of current progress, displaying completed sections, pending tasks, and critique iteration counts.

Tool access control is enforced through the Claude Code framework's `allowed-tools` configuration. The planning skill requires file system access (Read, Glob) and command execution (Bash) to analyze repository structure. The drafting skill additionally needs Write and Edit capabilities to create section files. The research skill is granted WebSearch and WebFetch permissions to retrieve literature. The critique skill operates read-only to prevent accidental manuscript modifications during review. This principle of least privilege reduces the risk of unintended file system changes and ensures each skill operates within its designated scope.

## Installation System

The installation process uses a global-local hybrid model designed to minimize redundancy across multiple research projects. The `install.sh` script supports three modes: `global`, `local`, and `setup-project`. Global installation creates symbolic links in `~/.claude/skills/` pointing to the skill definitions in the cloned repository. This enables one-time setup followed by automatic updates via `git pull` in the repository directory, propagating skill improvements to all projects immediately [wang2024gpt4].

Project setup (`setup-project` mode) creates the required directory structure without duplicating skill code. It generates `manuscript/`, `scripts/`, `schemas/`, `figures/`, `data/raw/`, and `data/processed/` directories, then copies language-agnostic verification tools (`rrwrite-verify-stats.py`, `rrwrite-validate-manuscript.py`) and the LinkML schema into the project. A `PROJECT.md` template is also copied to guide researchers in documenting their computational work using a structured format that the planning skill can parse. The script initializes the state file by calling `rrwrite-state-manager.py init`, which creates `.rrwrite/state.json` with default workflow stage markers.

The installation script automatically detects the repository location using `${BASH_SOURCE[0]}` to resolve relative paths, ensuring correct symbolic link creation regardless of where RRWrite is cloned. Existing installations are handled gracefully: the script removes stale symlinks before creating new ones, and skips `PROJECT.md` creation if the file already exists to avoid overwriting user customizations. File permissions are set appropriately (`chmod +x scripts/*.py`) to ensure verification tools are directly executable. A `.gitignore` template is generated to exclude transient manuscript outputs while preserving the state file for collaborative tracking.

The local installation mode (`local`) bypasses symbolic links and instead copies all skill files into the project's `.claude/skills/` directory. This mode supports project-specific skill customization but sacrifices the automatic update benefit of the global approach. It is recommended only for advanced users who need to modify skill behavior without affecting other projects. The modular design allows seamless switching between global and local modes by running the corresponding installation command, with state and manuscript outputs preserved across transitions.
